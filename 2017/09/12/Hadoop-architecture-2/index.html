<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hadoop 体系（二） | Ice&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上文简单介绍了Hadoop，以及Hadoop体系成员。接下来将对每个成员进行简单的介绍。
HBaseHBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于B">
<meta property="og:type" content="article">
<meta property="og:title" content="Hadoop 体系（二）">
<meta property="og:url" content="http://iceccb.github.io/2017/09/12/Hadoop-architecture-2/index.html">
<meta property="og:site_name" content="Ice's Blog">
<meta property="og:description" content="上文简单介绍了Hadoop，以及Hadoop体系成员。接下来将对每个成员进行简单的介绍。
HBaseHBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于B">
<meta property="og:image" content="http://iceccb.github.io/../image/Chukwa架构.png">
<meta property="og:image" content="http://iceccb.github.io/../image/Chukwa整体架构.jpg">
<meta property="og:image" content="http://iceccb.github.io/../image/Girph.png">
<meta property="og:image" content="http://iceccb.github.io/../image/Hive技术架构.png">
<meta property="og:image" content="http://iceccb.github.io/../image/Hive执行流程.png">
<meta property="og:image" content="http://iceccb.github.io/../image/sqoop架构.jpg">
<meta property="og:image" content="http://iceccb.github.io/../image/Mesos_sharing.jpg">
<meta property="og:updated_time" content="2017-09-12T08:47:03.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hadoop 体系（二）">
<meta name="twitter:description" content="上文简单介绍了Hadoop，以及Hadoop体系成员。接下来将对每个成员进行简单的介绍。
HBaseHBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于B">
  
    <link rel="alternative" href="/atom.xml" title="Ice&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
<!--   <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      
<header id="header">
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ice&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">everything will be ok</a>
        </h2>
      
    </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">博文</a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
      <nav id="sub-nav">
        
      </nav>
      
    </div>
  </div>
  <!--fork me on github-->
  <!--<a href="https://github.com/iceccb" id="fork-me-link"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>-->
</header>
      <div class="outer">
        <section id="main"><article id="post-Hadoop-architecture-2" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Hadoop 体系（二）
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/09/12/Hadoop-architecture-2/" class="article-date">
  <time datetime="2017-09-12T08:01:16.000Z" itemprop="datePublished">9月 12 2017</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据-Hadoop/">大数据 Hadoop</a></li></ul>

      
<a href="/2017/09/12/Hadoop-architecture-2/#comments" class="article-comment-link" data-thread-key="cj7zm5xg80039covgdfu292js" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>上文简单介绍了Hadoop，以及Hadoop体系成员。接下来将对每个成员进行简单的介绍。</p>
<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p>
<h2 id="高并发、实时处理"><a href="#高并发、实时处理" class="headerlink" title="高并发、实时处理"></a>高并发、实时处理</h2><p>Hadoop是一个高容错、高延时的分布式文件系统和高并发的批处理系统，不适用于提供实时计算；HBase是可以提供实时计算的分布式数据库，数据被保存在HDFS分布式文件系统上，由HDFS保证高容错性。</p>
<p>可以直接或通过HBase的存储HDFS数据。使用HBase在HDFS读取消费/随机访问数据。 HBase在Hadoop的文件系统之上，并提供了读写访问。HBase HRegion servers集群中的所有的region的数据在服务器启动时都是被打开的，并且在内冲初始化一些memstore，相应的这就在一定程度上加快系统响 应；而Hadoop中的block中的数据文件默认是关闭的，只有在需要的时候才打开，处理完数据后就关闭，这在一定程度上就增加了响应时间</p>
<h2 id="HBase和HDFS"><a href="#HBase和HDFS" class="headerlink" title="HBase和HDFS"></a>HBase和HDFS</h2><table>
<thead>
<tr>
<th style="text-align:left">HBase</th>
<th style="text-align:left">HDFS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HDFS是适于存储大容量文件的分布式文件系统</td>
<td style="text-align:left">HBase是建立在HDFS之上的数据库</td>
</tr>
<tr>
<td style="text-align:left">HDFS不支持快速单独记录查找</td>
<td style="text-align:left">HBase提供在较大的表快速查找</td>
</tr>
<tr>
<td style="text-align:left">提供了高延迟批量处理</td>
<td style="text-align:left">供了数十亿条记录低延迟访问单个行记录（随机存取）</td>
</tr>
<tr>
<td style="text-align:left">提供的数据只能顺序访问</td>
<td style="text-align:left">HBase内部使用哈希表和提供随机接入，并且其存储索引，可将在HDFS文件中的数据进行快速查找</td>
</tr>
</tbody>
</table>
<h2 id="HBase和RDBMS"><a href="#HBase和RDBMS" class="headerlink" title="HBase和RDBMS"></a>HBase和RDBMS</h2><table>
<thead>
<tr>
<th style="text-align:left">HBase</th>
<th style="text-align:left">RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HBase无模式，它不具有固定列模式的概念;仅定义列族</td>
<td style="text-align:left">RDBMS有它的模式，描述表的整体结构的约束</td>
</tr>
<tr>
<td style="text-align:left">宽表、横向扩展</td>
<td style="text-align:left">细而专为小表</td>
</tr>
<tr>
<td style="text-align:left">没有任何事务</td>
<td style="text-align:left">RDBMS是事务性的</td>
</tr>
<tr>
<td style="text-align:left">反规范化的数据</td>
<td style="text-align:left">规范化的数据</td>
</tr>
<tr>
<td style="text-align:left">半结构以及结构化数据</td>
<td style="text-align:left">结构化数据</td>
</tr>
</tbody>
</table>
<h1 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h1><p>Cassandra是一个开源的分布式NoSQL数据存储系统，在实现了BigTable的数据模型的同时，使用了基于Amazon的Dynamo的系统架构来存储数据。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Cassandra使用了Google 设计的 BigTable的数据模型，与面向行(row)的传统的关系型数据库或键值存储的key-value数据库不同，Cassandra使用的是宽列存储模型(Wide Column Stores)，每行数据由row key唯一标识之后，可以有最多20亿个列，每个列由一个column key标识，每个column key下对应若干value。</p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p>Cassandra的数据并不存储在分布式文件系统如GFS或HDFS中，而是直接存于本地。与BigTable一样，Cassandra也是日志型数据库，即把新写入的数据存储在内存的Memtable中并通过磁盘中的CommitLog来做持久化，内存填满后将数据按照key的顺序写进一个只读文件SSTable中，每次读取数据时将所有SSTable和内存中的数据进行查找和合并。这种系统的特点是写入比读取更快，因为写入一条数据是顺序计入commit log中，不需要随机读取磁盘以及搜索。</p>
<h2 id="与HBase比较"><a href="#与HBase比较" class="headerlink" title="与HBase比较"></a>与HBase比较</h2><table>
<thead>
<tr>
<th style="text-align:left">Cassandra</th>
<th style="text-align:left">HBase</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">只有一种节点，存储在本地</td>
<td style="text-align:left">有多种角色，架构在HDFS上，需要ZooKeeper同步集群状态</td>
</tr>
<tr>
<td style="text-align:left">数据一致性策略是可配置的，可选择是强一致性还是性能更高的最终一致性</td>
<td style="text-align:left">总是强一致性的</td>
</tr>
<tr>
<td style="text-align:left">一致性哈希实现负载均衡</td>
<td style="text-align:left">每段数据由一个节点处理，由master动态分配实现负载均衡 </td>
</tr>
<tr>
<td style="text-align:left">无单点问题</td>
<td style="text-align:left">有单点问题</td>
</tr>
</tbody>
</table>
<h1 id="Chukwa"><a href="#Chukwa" class="headerlink" title="Chukwa"></a>Chukwa</h1><p>chukwa 是一个开源的用于监控大型分布式系统的数据收集系统。这是构建在 hadoop 的 hdfs 和 map/reduce 框架之上的。还包含了一个强大和灵活的工具集，可用于展示、监控和分析已收集的数据。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="../image/Chukwa架构.png" alt="Chukwa架构" title="Chukwa架构"></p>
<p><img src="../image/Chukwa整体架构.jpg" alt="Chukwa整体架构" title="Chukwa整体架构"></p>
<ul>
<li>agents : 负责采集最原始的数据,并发送给 collectors</li>
<li>adaptor : 直接采集数据的接口和工具,一个 agent 可以管理多个 adaptor 的数据采集</li>
<li>collectors 负责收集 agents 收送来的数据,并定时写入集群中</li>
<li>map/reduce jobs 定时启动,负责把集群中的数据分类、排序、去重和合并</li>
<li>HICC 负责数据的展示</li>
</ul>
<h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><p>Flume是一个分布式、可靠、和高可用的海量日志聚合的系统，支持在系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：end-to-end（收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。），Store on failure（这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送），Best effort（数据发送到接收方后，不会进行确认）。</p>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>Flume采用了三层架构，分别为agent，collector和storage，每一层均可以水平扩展。其中，所有agent和collector由master统一管理，这使得系统容易监控和维护，且master允许有多个（使用ZooKeeper进行管理和负载均衡），这就避免了单点故障问题。</p>
<h2 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h2><p>所有agent和colletor由master统一管理，这使得系统便于维护。多master情况，Flume利用ZooKeeper和gossip，保证动态配置数据的一致性。用户可以在master上查看各个数据源或者数据流执行情况，且可以对各个数据源配置和动态加载。Flume提供了web 和shell script command两种形式对数据流进行管理。</p>
<h2 id="功能可扩展性"><a href="#功能可扩展性" class="headerlink" title="功能可扩展性"></a>功能可扩展性</h2><p>用户可以根据需要添加自己的agent，collector或者storage。此外，Flume自带了很多组件，包括各种agent（file， syslog等），collector和storage（file，HDFS等）。</p>
<h1 id="Giraph"><a href="#Giraph" class="headerlink" title="Giraph"></a>Giraph</h1><p>Giraph是一个迭代的图计算系统。Giraph计算的输入是由点和直连的边组成的图。是基于Hadoop建立的。</p>
<p>现在的大数据的图问题又很多，例如表达人与人之间的关系的有社交网络，搜索引擎需要经常计算网页与网页之间的关系，而map-reduce接口不太适合实现图算法。</p>
<p><img src="../image/Girph.png" alt="Giraph" title="Giraph"></p>
<h1 id="Hama"><a href="#Hama" class="headerlink" title="Hama"></a>Hama</h1><p>Apache Hama是一个建立在Hadoop上基于BSP（Bulk Synchronous Parallel）的计算框架，模仿了Google的Pregel。用来处理大规模的科学计算，特别是矩阵和图计算。集群环境中的系统架构由 BSPMaster/GroomServer（Computation Engine）、Zookeeper（Distributed Locking）、HDFS/HBase（Storage Systems）这3大块组成。 </p>
<h2 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h2><p>整体同步并行计算模型(Bulk Synchronous Parallel Computing Model，简称BSP模型)，又名大同步模型或BSP模型。</p>
<p>BSP模型最早作为一 个并行计算领域中软件和硬件之间 的“ 过渡模型” 而提 出的。它的设计目标是为 现有 和未来 可能出现的各种 并行体系结构提供一个独立于具体体系结构、具有可扩展并行性能的软件开发的良好的理论模型基础。<br>一个BSP计算机由一组通过通讯网络互连的处理器——内存单元组成。它主要有三个部分:</p>
<ul>
<li>一组具有局部内存的分布式处理器</li>
<li>全局数据通讯网络</li>
<li>支持所有处理单元间全局路障同步的机制</li>
</ul>
<h2 id="Hama的BSP实现原理"><a href="#Hama的BSP实现原理" class="headerlink" title="Hama的BSP实现原理"></a>Hama的BSP实现原理</h2><p>Hama可以说是一个利用Hadoop的基础设施自封装的一个BSP计算模型的实现，它虽然跟Hadoop有关但是不使用Hadoop集群，而是用的自身的集群。依赖ZooKeeper分布式锁作为作业的调度控制，可以用HDFS/Local/HBase等文件系统作输入输出。</p>
<h1 id="HCatalog"><a href="#HCatalog" class="headerlink" title="HCatalog"></a>HCatalog</h1><p>HCatalog是Hadoop的元数据和数据表的管理系统。它基于Hive中的元数据层，通过类似SQL的语言展现Hadoop数据的关联关系。 HCatalog允许用户通过Hive，Pig，MapReduce共享数据和元数据。它的另一特点就是在用户编写应用程序时无需关心数据怎么存储，在哪里存储，还避免用户因schema和存储格式的改变而受到影响。</p>
<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p>Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。</p>
<p>它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。Hive 并不适合那些需要低延迟的应用，例如，联机事务处理（OLTP）。</p>
<h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p><img src="../image/Hive技术架构.png" alt="Hive技术架构图" title="Hive技术架构图"></p>
<h3 id="Driver组件"><a href="#Driver组件" class="headerlink" title="Driver组件"></a>Driver组件</h3><p>该组件包括Complier、Optimizer和Executor，它的作用是将HQL语句进行解析、编译优化，生成执行计划，然后调用底层的mapreduce计算框架。</p>
<h3 id="Metastore组件"><a href="#Metastore组件" class="headerlink" title="Metastore组件"></a>Metastore组件</h3><p>元数据服务组件，这个组件存储hive的元数据，hive的元数据存储在关系数据库里，hive支持的关系数据库有derby、mysql。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性。</p>
<h3 id="Thrift服务"><a href="#Thrift服务" class="headerlink" title="Thrift服务"></a>Thrift服务</h3><p>thrift是facebook开发的一个软件框架，它用来进行可扩展且跨语言的服务的开发，hive集成了该服务，能让不同的编程语言调用hive的接口。</p>
<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>命令行。</p>
<h3 id="Thrift-client"><a href="#Thrift-client" class="headerlink" title="Thrift client"></a>Thrift client</h3><p>hive架构的许多客户端接口是建立在thrift客户端之上，包括JDBC和ODBC接口。</p>
<h3 id="Web-GUI"><a href="#Web-GUI" class="headerlink" title="Web GUI"></a>Web GUI</h3><p>一种通过网页的方式访问hive所提供的服务。</p>
<h2 id="Hive执行流程"><a href="#Hive执行流程" class="headerlink" title="Hive执行流程"></a>Hive执行流程</h2><p><img src="../image/Hive执行流程.png" alt="Hive执行流程" title="Hive执行流程"></p>
<h1 id="Hue"><a href="#Hue" class="headerlink" title="Hue"></a>Hue</h1><p>HUE（Hadoop User Experience）是一个开源的Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。</p>
<p>通过使用Hue我们可以在浏览器端的Web控制台上与Hadoop集群进行交互来分析处理数据，例如操作HDFS上的数据，运行MapReduce Job，执行Hive的SQL语句，浏览HBase数据库等等。</p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul>
<li>SQL编辑器，支持Hive, Impala, MySQL, Oracle, PostgreSQL, SparkSQL, Solr SQL, Phoenix…</li>
<li>搜索引擎Solr的各种图表</li>
<li>Spark和Hadoop的友好界面支持</li>
<li>支持调度系统Apache Oozie，可进行workflow的编辑、查看</li>
</ul>
<h1 id="Oozie"><a href="#Oozie" class="headerlink" title="Oozie"></a>Oozie</h1><p>在Hadoop中执行的任务有时候需要把多个Map/Reduce作业连接到一起，这样才能够达到目的。Oozie可以把多个Map/Reduce作业组合到一个逻辑工作单元中，从而完成更大型的任务。</p>
<p>Oozie是一种Java Web应用程序，它运行在Java servlet容器——即Tomcat——中，并使用数据库来存储以下内容：工作流定义；当前运行的工作流实例，包括实例的状态和变量。</p>
<h1 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h1><p>主要用来在Hadoop和关系数据库中传递数据。通过sqoop，我们可以方便的将数据从关系数据库导入到HDFS，或者将数据从HDFS导出到关系数据库。</p>
<h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><p><img src="../image/sqoop架构.jpg" alt="sqoop架构" title="sqoop架构"></p>
<h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p>
<h1 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h1><p>不同的分布式运算框架(spark,hadoop,ES,MPI,Cassandra,etc.)中的任务往往需要的不同的资源（内存，CPU，网络IO等），它们运行在同一个集群中，会相互干扰，为此，应该提供一种资源隔离机制避免任务之间由资源争用导致效率下降,考虑到资源利用率，运维成本，数据共享等因素，便诞生了资源统一管理与调度平台,典型的代表就是mesos和yarn。</p>
<p>Mesos的目标就是在不同的framework之间高效的共享硬件资源，同时简化自身的调度逻辑，使其具有尽可能大的兼容性和可扩展性，以保证在大规模集群使用环境下的健壮性和对各种可能的运算框架的普遍适用性。</p>
<p>Mesos最大的好处是能够对分布式集群做细粒度资源分配。Mesos的分配逻辑很简单，只要不停地报告哪些是可用资源就可以了。Mesos资源分配方法也有一个潜在的缺点，就是无中心化的分配方式，所以有可能不会带来全局最优的方式。</p>
<p><img src="../image/Mesos_sharing.jpg" alt="Mesos sharing" title="Mesos sharing"></p>
<h2 id="Mesos-master"><a href="#Mesos-master" class="headerlink" title="Mesos-master"></a>Mesos-master</h2><p>协调全部的slave，并确定每个节点的可用资源，聚合计算跨节点的所有可用资源的报告，然后向注册到Master的Framework发出资源邀约。</p>
<h2 id="Mesos-slave"><a href="#Mesos-slave" class="headerlink" title="Mesos-slave"></a>Mesos-slave</h2><p>向master汇报自己的空闲资源和任务的状态，负责管理本节点上的各个mesos-task，在framework成功向Master申请资源后,收到消息的slave会启动相应framework的exexutor。</p>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>Hadoop，Spark等，通过 <strong>MesosSchedulerDiver</strong> 接入Mesos。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>执行器，用于启动计算框架中的task。</p>
<h2 id="Yarn和Mesos比较"><a href="#Yarn和Mesos比较" class="headerlink" title="Yarn和Mesos比较"></a>Yarn和Mesos比较</h2><ul>
<li>Mesos只负责offer资源给framework，而Yarn自己来分配资源。</li>
<li>Yarn局限在Hadoop上，没法作为别的机器管理。</li>
<li>Mesos管理CPU，Memory，Disk；而Yarn只管理Memory和CPU。</li>
<li>Mesos用lxc隔离，Yarn用进程来进行隔离（性能可能更好）。</li>
<li>部署Mesos以后，再跑Spark或Hadoop MapReduce的时候，就不需要部署Spark和Hadoop了，直接在Mesos上运行Spark或Hadoop任务(在文件系统中指定运行所需要的框架二进制包位置)。</li>
<li>两种系统都采用了双层调度机制，即，第一层是源管理系统（mesos/YARN）将资源分配给应用程序（或框架），第二层，应用程序将收到的资源进一步分配给内部的任务。但是资源分配器智能化程度不同，mesos是基于resource offer的调度机制，包含非常少的调度语义，他只是简单的将资源推给各个应用程序，由应用程序选择是否接受资源，而mesos本身并不知道各个应用程序资源需求；YARN则不同，应用程序的ApplicationMaster会把各个任务的资源要求汇报给YARN，YARN则根据需要为应用程序分配资源。</li>
<li>从功能上讲YARN和Mesos相似，只是Mesos更通用，可以支持在线和离线任务。一般YARN用于调度离线任务。</li>
</ul>

      
    </div>
    
      <footer class="article-footer">
        
<!-- baidu share -->
<div class="bdsharebuttonbox" style="float: right">
  <a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a>
  <a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a>
  <a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a>
  <a title="分享到Facebook" href="#" class="bds_fbook" data-cmd="fbook"></a>
  <a title="分享到Twitter" href="#" class="bds_twi" data-cmd="twi"></a>
  <a href="#" class="bds_more" data-cmd="more"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<!-- End baidu share -->


      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/25/zhengwu-ziyuan-mulu/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          政务信息资源目录编制指南（试行）
        
      </div>
    </a>
  
  
    <a href="/2017/09/07/135-zhengwu-IT-guihua/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">一图读懂“十三五”国家政务信息化工程建设规划</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="cj7zm5xg80039covgdfu292js" data-title="Hadoop 体系（二）" data-url="http://iceccb.github.io/2017/09/12/Hadoop-architecture-2/" id="duoshuo"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"iceccb"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>




</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-category">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-recent">最近</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/25/zhengwu-ziyuan-mulu/">政务信息资源目录编制指南（试行）</a>
          </li>
        
          <li>
            <a href="/2017/09/12/Hadoop-architecture-2/">Hadoop 体系（二）</a>
          </li>
        
          <li>
            <a href="/2017/09/07/135-zhengwu-IT-guihua/">一图读懂“十三五”国家政务信息化工程建设规划</a>
          </li>
        
          <li>
            <a href="/2017/09/07/Hadoop-architecture-1/">Hadoop 体系（一）</a>
          </li>
        
          <li>
            <a href="/2017/09/01/p2v-transfer/">虚拟机p2v迁移介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-tag">标签</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/ejs/" style="font-size: 16px;">ejs</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/language/" style="font-size: 10px;">language</a> <a href="/tags/network-openflow/" style="font-size: 10px;">network openflow</a> <a href="/tags/network-sdn/" style="font-size: 12px;">network sdn</a> <a href="/tags/nodejs/" style="font-size: 12px;">nodejs</a> <a href="/tags/web/" style="font-size: 20px;">web</a> <a href="/tags/云计算-方案/" style="font-size: 10px;">云计算 方案</a> <a href="/tags/大数据-Hadoop/" style="font-size: 12px;">大数据 Hadoop</a> <a href="/tags/政策/" style="font-size: 10px;">政策</a> <a href="/tags/电影/" style="font-size: 14px;">电影</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a> <a href="/tags/话剧/" style="font-size: 10px;">话剧</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/读后感/" style="font-size: 14px;">读后感</a> <a href="/tags/随笔/" style="font-size: 18px;">随笔</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ice Chan<br>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">博文</a>
  
</nav>
    
<script src="/js/jquery-1.9.1.min.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>