<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ice&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Ice's Blog">
<meta property="og:url" content="http://iceccb.github.io/index.html">
<meta property="og:site_name" content="Ice's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ice's Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Ice&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
<!--   <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      
<header id="header">
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ice&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">everything will be ok</a>
        </h2>
      
    </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">博文</a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
      <nav id="sub-nav">
        
      </nav>
      
    </div>
  </div>
  <!--fork me on github-->
  <!--<a href="https://github.com/iceccb" id="fork-me-link"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>-->
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-data-center-network-serias-3-ONOS" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/31/data-center-network-serias-3-ONOS/">数据中心网络系列(3)--ONOS</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/31/data-center-network-serias-3-ONOS/" class="article-date">
  <time datetime="2017-08-31T00:32:14.000Z" itemprop="datePublished">8月 31 2017</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-sdn/">network sdn</a></li></ul>

      
<a href="/2017/08/31/data-center-network-serias-3-ONOS/#comments" class="article-comment-link" data-thread-key="cj6zpy46v002i8gvghq18fnz3" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="标准化组织"><a href="#标准化组织" class="headerlink" title="标准化组织"></a>标准化组织</h1><p>目前全球SDN产业正从技术研究走向商用部署、方案落地，全球范围内已开始出现商业应用的案例。在电信网络中，SDN受到全球众多运营商和ICT企业的高度关注和推进。SDN已经开始向传输网路、云端服务、无线通讯等各个相关领域延伸。</p>
<p>谷歌、微软等互联网公司均在SDN领域投入了大量的科研力量，思科、华为、爱立信、IBM、HP等IT厂商也正在研制SDN控制器和交换机。业界也成立了相应的标准化组织，比如ONF和OpenDaylight。</p>
<h1 id="ONOS"><a href="#ONOS" class="headerlink" title="ONOS"></a>ONOS</h1><p>由斯坦福大学和加州大学伯克利分校SDN先驱创立的非营利性组织ON.Lab推出了自己的开源SDN操作系统——ONOS。ONOS是一个高可靠、高性能、可扩展和灵活的抽象成SDN操作系统。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ONOS是第一个开源的SDN操作系统，面向服务提供商和企业骨干网。ONOS旨在满足高可靠、高性能和可扩展性的网络需求。ONOS的北向接口抽象层和API使得应用开发变得更加简单，而通过南向接口抽象层和接口则可以管控OpenFlow或者传统设备。</p>
<ul>
<li>使得SDN控制层具有电信级特征（可扩展、可靠、性能）</li>
<li>保证网络敏捷性</li>
<li>帮助服务提供商从现有网络迁移到白牌机</li>
<li>减少服务提供商的资本支出和运营开支</li>
</ul>
<h2 id="服务提供商需求"><a href="#服务提供商需求" class="headerlink" title="服务提供商需求"></a>服务提供商需求</h2><p>随着移动设备的不断普及以及基于云的OTT服务和内容分发的兴起，导致服务提供商的网络迫切需要进行一次网络变革。服务提供商希望网络可以变得更加敏捷高效来应对指数级带宽增长所带来的挑战，同时希望能从创新型服务和新型业务模式中分一杯羹。</p>
<h2 id="SDN和ONOS解决方案"><a href="#SDN和ONOS解决方案" class="headerlink" title="SDN和ONOS解决方案"></a>SDN和ONOS解决方案</h2><p>SDN问世后迅速成为实现移动性、虚拟化、云服务的技术选择。存储和计算虚拟化已经相对成熟，但是云计算技术的价值并未完全开发出来，由于它们都需要连接在网络上，通过网络与应用连接，但是网络无法满足这些新兴技术的需求，因此成了它们发展的瓶颈。</p>
<p>SDN的核心理念是将竖井式结构的网络设备的控制平面和数据平面分离。控制平面通过像OpenFlow这样的开放性协议对数据平面进行高效的管控。另外，通过解除网络硬件与软件的绑定关系使得两者可以独立演进并促使商业硬件和开源软件替代昂贵的专用硬件。利用操作系统管理网络资源并且提供管理、监控的抽象层和API接口，通过对网络设备的编程可以极大地简化运行在大量硬件平台上的创新应用和服务的开发。ONOS就定位于上述操作系统，并且致力于以下目标：</p>
<ul>
<li>将网络应用开发者从复杂的专用硬件中解放出来</li>
<li>让网络运营者摆脱基于专用型接口和协议的运维复杂难题</li>
<li>解除软件与硬件的捆绑，分别独立进行创新发展</li>
</ul>
<h2 id="为什么需要网络操作系统"><a href="#为什么需要网络操作系统" class="headerlink" title="为什么需要网络操作系统"></a>为什么需要网络操作系统</h2><p>即使现在有许多开源的SDN控制器，但它们只具有比较原始的编程接口和面向设备的抽象，不具备商业化的属性：可靠、性能、可扩展。这些控制器直接向网络应用发送OpenFlow消息，而网络应用直接为网络设备创建OpenFlow消息。这样看来，这些控制器更像是设备驱动。因此才需要有网络操作系统，并具备下述功能：</p>
<ul>
<li>提供资源消费者公平、合理管理有限的资源</li>
<li>隔离和保护NOS用户，应用和设备复用所有的资源，且能虚拟化部分或全部资源分配给用户的OS虚拟化实例</li>
<li>提供安全保障</li>
<li>提供可复用的服务</li>
</ul>
<h2 id="ONOS架构"><a href="#ONOS架构" class="headerlink" title="ONOS架构"></a>ONOS架构</h2><p>ONOS的核心功能：</p>
<ul>
<li>分布式核心：提供可扩展性、高可靠性和高性能。以集群方式运行使得SDN控制平台和服务提供商网络具有类似Web风格的灵活性</li>
<li>北向接口抽象层/APIs：将网络和应用与控制、管理和配置服务的发展解耦</li>
<li>南向接口抽象层/APIs：通过插件式南向接口协议可以控制OpenFlow设备和传统设备。南向接口抽象层隔离ONOS的核心功能和底层设备，屏蔽底层设备和协议的差异性。南向接口是从传统设备向OpenFlow白牌设备迁移的关键</li>
<li>软件模块化：让ONOS像软件系统一样，便于社区开发者和提供者进行开发、调试、维护和升级</li>
</ul>
<h3 id="分布式核心"><a href="#分布式核心" class="headerlink" title="分布式核心"></a>分布式核心</h3><p>ONOS以集群方式部署，支持快速故障恢复、无中断的扩展，轻松扩容控制平面。对于应用和网络设备来说平台这是透明的，无需关注与ONOS实例交互。</p>
<p><img src="../images/onos-distributed-core.png" alt="ONOS分布式核心" title="ONOS分布式核心"></p>
<p>分布式核心提供实例间通信（Publish/Subscribe模型）、状态管理和leader选举。ONOS使用多种机制管理实例的操作状态，并且每种机制与状态类型一一对应。其中典型的例子就是应用意图、拓扑数据库和流表，每个都有独一无二的规模、读/写模式和持久化需求。这保证集群的高吞吐量、低时延以及高可用性。</p>
<p>这意味着，对设备而言，只有一个leader ONOS实例，leader出现故障时无需重新创建新实例并重新同步流表。对于应用而言，可以通过网络图形抽象层持续获取网络的视图。此外，实例故障和数据平面的故障对应用来说是透明的，这样可以极大地简化应用开发和错误处理。从业务角度上，其提供可高可用、无中断的、易扩容的环境。</p>
<h3 id="北向抽象层"><a href="#北向抽象层" class="headerlink" title="北向抽象层"></a>北向抽象层</h3><p>包括意图框架和全局网络视图。意图框架允许应用向网络请求服务（与API类似），提供高层次的编程。</p>
<p>意图框架实例：</p>
<ul>
<li>主机A和主机B建立通信</li>
<li>在交换机X和交换机Y间建立带宽Z的通道</li>
<li>不允许主机A和主机B通信</li>
</ul>
<p><img src="../images/onos-intent-framework.png" alt="ONOS意图框架" title="ONOS意图框架"></p>
<p>意图框架处理所有应用的请求，判断可以满足哪些应用，解决应用之间的冲突，执行管理者的策略，对网络编程提供请求的功能，交付请求的服务给应用。一个意图转化为多个目标。例如，一个连接2个主机的意图转化为2个目标，各提供一个方向的流。将意图转化的目标编译成指令发送给网络设备，整个流程按照网络运维人员指定的策略进行。从某种程度上说这个方法可以解决意图之间的冲突。</p>
<p>全局网络视图为应用提供了网络视图，包括主机、交换机以及网络相关的状态参数，如利用率。应用可以通过APIs对网络视图进行编程，一个API可以为应用以网络图的形式提供网络视图。包括：</p>
<ul>
<li>创建一个简单应用，在该应用获得网络视图后计算最短路径</li>
<li>通过监控网络视图和编程修改路径来调节负载（流量工程），最大化网络利用率</li>
<li>将流量从正在升级或因病毒被隔离的网络中引导出来</li>
</ul>
<p>北向接口抽象层和APIs将应用与网络细节进行隔离。而且也可以隔离需要了解网络事件（如链路中断）的应用和其它应用。将网络操作系统与应用隔离，网络操作系统可以管理来自多个、竞争应用的请求。从业务角度看，提高了应用开发速度，允许网络改变并且保证应用不会当机。</p>
<h3 id="南向抽象层"><a href="#南向抽象层" class="headerlink" title="南向抽象层"></a>南向抽象层</h3><p>南向抽象层由网络组件如交换机、主机和链路组成。ONOS南向抽象层将每个网络组件在一个通用表中表示为对象。通过这种抽象，分布式核心可以在不用了解底层设备细节的情况下维护网络组件的状态。分布式核心可以实现南向接口协议和设备无感知。网络组件抽象允许添加新设备和协议，允许可插拨的形式支持扩展，插件根据规格映射（或翻译）通用网络组件描述或操控设备。因此ONOS可以控制和管理使用不同协议（Openflow、NetConf等）的设备。</p>
<p><img src="../iamges/onos-onos-layers.png" alt="ONOS层次" title="ONOS层次"></p>
<p>在架构上，底层为网络设备或组件，ONOS通过协议与之交互。协议细节被网络组件插件或适配器屏蔽。因此南向接口的核心可以在不了解道具体协议细节和网络组件的条件下维护网络组件对象（设备、主机、链路），通过适配层API，分布式核心可以与网络组件对象的状态保持一致，适配层API将分布式核心与协议细节和网络组件相隔离。</p>
<p>南向抽象层的主要优点：</p>
<ul>
<li>管理使用不同协议的不同设备，并不影响系统的分布式核心</li>
<li>可扩展新设备和新协议</li>
<li>非常简单的实现传统设备向支持Openflow的白牌设备转移</li>
</ul>
<h3 id="软件模块化"><a href="#软件模块化" class="headerlink" title="软件模块化"></a>软件模块化</h3><p>软件模块化是ONOS一大特征，基于软件的形式可以很方便地进行添加、改变和维护。</p>
<p>从宏观结构上说，北向接口与南向接口API将应用、分布式核心和适配层相互隔离，可以独立添加新的应用和协议适配器。</p>
<p>同样，从具体细节来看，分布式核心内部的子结构也能体现模块化特征，分布式核心的存在价值就是约束所有子系统的规模并保证模块的可拓展性。此外，连接不同模块的接口是至关重要的，允许模块不依赖其他模块独立更新。这样就可以不断更新算法和数据结构，并且不会影响整体系统或是应用。</p>
<p>显然，接口可以促进模块业务和职责的分离，尽量使子系统之间的交互更为自然、简单。这一特点是确保软件稳定更新的关键。例如，尽量提供南向API的抽象程度，避免将不同协议的偏差传递到上层，并且强化分布式核心而不是适配层来创建网络模型对象。</p>
<p>ONOS源代码的树形结构不仅仅为了遵循而是要加强这些结构原则。合理控制模块大小并且模块之间保持适当依赖形成一个非循环的结构图，模块之间通过API模块相互关联。</p>
<p><img src="../images/onos-modules.png" alt="ONOS Modules" title="ONOS Modules"></p>
<p>软甲模块化的优点：</p>
<ul>
<li>架构的完整性和连贯性</li>
<li>简化测试结果，允许更多集成测试</li>
<li>降低维护难度，且降低因为改变造成的负面影响</li>
<li>可扩展和可定制的组件</li>
<li>避免循环依赖</li>
</ul>
<h2 id="ONOS价值主张-运营商用例"><a href="#ONOS价值主张-运营商用例" class="headerlink" title="ONOS价值主张-运营商用例"></a>ONOS价值主张-运营商用例</h2><h3 id="多层SDN控制"><a href="#多层SDN控制" class="headerlink" title="多层SDN控制"></a>多层SDN控制</h3><p>服务提供商运营多层的网络。如，一个服务提供商可能同时运营IP数据网络和传输网络或是光网络。IP层上可能有一个隧道层，创建类似于虚拟IP层网络这样的服务。目前这些层都是独立管理，这导致了较低的网络利用率、高运维成本和较长的重新配置周期。例如，在现在的环境下，数据网络设计者一般会预留一定的带宽用于解决网络故障和网络潮汐现象。而传输网络设计者也会做相同的预留。再者，数据网络设计者倾向于网络平均利用率保持在30%。所以，总计会造成网络容量4-5倍的过度配置。</p>
<p>SDN多层网络控制解决了上述问题。解决方案包括：</p>
<ol>
<li>扩展Openflow，如向光传输单元（如ROADMs）添加可编程性</li>
<li>ONOS为每层网络创建网络图形视图并且维护它们间通信和映射</li>
<li>在ONOS上开发PCE应用根据多重关联网络视图来建立、拆除路径</li>
</ol>
<p>PCE应用是一个单独可以配置、监控和编排各层网络的单元。如，IP连接改变可以触发光路径的自动化配置。这样，运营商可以通过中心控制降低运营成本、提高各层的网络利用率和快速重新配置网络。这种网络能力的应用之一就是带宽计划应用，允许带宽预留。ONOS预备数据层和光网络层资源提供带宽保证，并监控资源，根据最新的网络事件和其他改变进行重路由和调整操作。</p>
<p><img src="../images/ONOS-Multi-layer-SDN-control.png" alt="ONOS Multi layer SDN control" title="Multi layer SDN control"></p>
<p>SDN多层网络控制是ONOS怎样实现SDN控制的典型范例，可以有效地降低资本开支和运营开支，并且方便创建新型服务。</p>
<h3 id="SDN-IP-Peering和SDN控制平面扩展"><a href="#SDN-IP-Peering和SDN控制平面扩展" class="headerlink" title="SDN-IP Peering和SDN控制平面扩展"></a>SDN-IP Peering和SDN控制平面扩展</h3><p>现今，自治系统（AS）与互联网连接，并通过BGP彼此共享路由信息。ONOS的SDN-IP peering应用帮助运营商有小到大发展他们的SDN网络。运营商可部署一个小型的SDN网络或孤岛如AS，并且通过SDN-IP peering应用利用BGP协议将SDN网络与网络其他部分进行无缝互联。这样，一个SDN网络对互联网其他部分而言只是另外一个AS。并可以通过互联各个SDN网络构建更大的SDN网络。</p>
<p>SDN-IP 应用与AS边缘路由器互联，像现今标准自治系统间交换IP前缀路由信息。SDN-IP peering应用使用路由信息为SDN网络中多个网络前缀建立转发路径。所以，SDN网络对于一些前缀而言跟传输网一样可以向或者从任何可达IP地址转发IP流量。</p>
<p>另外，SDN-IP应用可以被用来扩展以ONOS为基础的SDN控制平台。例如，SDN网络可以像非SDN自治系统一样通过BGP互联，考虑到这些SDN网络以同样的方式工作，其它互联网可以将一组SDN域看成是一个单独的AS。</p>
<p><img src="iamge/ONOS-SDN-IP.png" alt="ONSO SDN-IP" title="ONSO SDN-IP"></p>
<h3 id="中心局的网络功能即服务（NFaaS）"><a href="#中心局的网络功能即服务（NFaaS）" class="headerlink" title="中心局的网络功能即服务（NFaaS）"></a>中心局的网络功能即服务（NFaaS）</h3><p>电信运行商拥有最宝贵的财富即中心局，这些中心局从地理位置上更靠近大量的终端用户，所以这也是保证电信运营商为大量用户提供灵活高效服务的关键。一个典型的中心局有很多接入、交换容量，各种网络功能的中间设备。尽管中心局对电信运营商很重要，但是已经发展了很多年并且在网络交换/路由、中间设备和用户终端方面复杂性越来越高，这就意味着需要大量的资本开支和运营开支。</p>
<p>不出意外，电信运营商想重构中心局，希望将数据中心的经济、灵活应用到中心局。这就意味着使用SDN来设计中心局结构，将中间设备的网络功能以软件的形式转移到x86服务器（NFV网络功能虚拟化），通过编排系统为用户和企业用户编排网络功能和网络流量，动态地服务各类用户实现用户及提供者双方各种各样的策略。</p>
<p><img src="ONOS-NFaaS-in-Central-Office.png" alt="NFaaS" title="NFaaS"></p>
<p>中心局的这一转变可以让服务提供商能够快速地建立、部署、提供新的服务，与此同时大大缩减了成本开支和运营开支。ONOS及其应用和OpenFlow交换机将助推中心局网络结构转型为SDN结构，为网络功能即服务提供所需的灵活度。我们希望从两个方向深化这个用例：演示ONOS可以作为重新构建中心局的网络操作系统的灵活性和性能；演示SDN和网络功能即服务怎样适应更大规模的中心局架构。</p>
<h3 id="分段路由-发展和改进MPLS"><a href="#分段路由-发展和改进MPLS" class="headerlink" title="分段路由-发展和改进MPLS"></a>分段路由-发展和改进MPLS</h3><p>如今，IP/MPLS网络非常复杂且难以管理。标签分发、路由工程和VPN都是复杂的操作和服务，依赖于控制平台上分布式协议的集合。网络调试难度大，很难顾及控制平台和标签交换数据平台上多个协议间的同步性和状态管理问题。</p>
<p>IETF已经为MPLS引入了分段路由的概念。它引入了不需要每一跳都交换的全局标签。还引入了基于标签的源路由，消除对标签分发和LSP建立中复杂协议（如LDP、RSVP）的依赖。就这样分段路由简化了MPLS网络的控制层和数据层。然而SR的路由和标签分发依旧依赖一个内部网关协议，它使外部控制器可以控制源路由器发起的端到端隧道。</p>
<p>分段路由用例正寻求与ONF的SPRING-OPEN项目合作。这个项目演示怎样基于ONOS和SR应用打造的SDN控制平台实现分段路由，并且能够运行在基于现有芯片的路由器裸机上。这个方案并没有使用路由器内嵌的分布式IGP，而是使用了ONOS上的一个路由应用。而且该应用控制边缘路由器和中心路由器的缺省路由和基于策略的路由，使用分段路由规则进行转发。网络操作者可以向控制器传达自己的策略需求，ONOS及其应用管理网络中的标签就可以在IP/MPLS网络上实现这些策略控制。</p>
<p><img src="../images/ONOS-Segment-Routing.png" alt="Segment Routing" title="Segment Routing"></p>
<p>所以ONOS的分段路由演示了服务提供商怎样在MPLS数据平面上构建简单的控制层，所以它兼具SR MPLS数据平面的简单性和SDN控制平面的灵活性。</p>

      
    </div>
    
  </div>
  
</article>






  
    <article id="post-data-center-network-serias-2-openflow" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/25/data-center-network-serias-2-openflow/">数据中心网络系列(2)--openflow</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/25/data-center-network-serias-2-openflow/" class="article-date">
  <time datetime="2017-08-25T13:30:09.000Z" itemprop="datePublished">8月 25 2017</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-openflow/">network openflow</a></li></ul>

      
<a href="/2017/08/25/data-center-network-serias-2-openflow/#comments" class="article-comment-link" data-thread-key="cj6zpy46x002l8gvg0wchv4h1" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Openflow"><a href="#Openflow" class="headerlink" title="Openflow"></a>Openflow</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>随着互联网的发展，对于网络的要求越来越高，网络技术的变革显得尤为重要，但由于如今的网络过于依赖设备和协议，不易于进行网络技术的研究。网络设备厂商将设备与协议绑定，形成一个不开放的环境，让他们开放平台似乎是不可能的事，并且也没有有效的途径在生产网络上实验新的技术。这导致了网络技术的发展停滞不前。</p>
<p>为了解决上述问题，Openflow应运而生，其主要实现以下的目标：</p>
<ul>
<li>贯彻高性能和低成本的需求</li>
<li>支持范围广泛的研究</li>
<li>保证隔离实验和生产网络</li>
<li>与设备厂商封闭平台需求保持一致</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>现代以太网交换机和路由器包含流表来实现防火墙、NAT、QoS和收集策略，但每个厂商的设备的流表都不一样，缺乏统一兼容的协议。因此Openflow提供一个开源的协议来对流表进行编程。如此，管理员可以控制不同的流，选择数据包的路由和处理接受的包，这样可以隔离生产和实验测试网络，也可以进行新协议的研究。</p>
<p>一个Openflow交换机由三部分组成：</p>
<ul>
<li>一个流表，和与每条流绑定的行为（指明如何处理流）</li>
<li>一个加密通道，连接交换机和控制器，命令和数据包通过这个通道进行传输</li>
<li>Openflow协议，提供开源和标准方法进行控制器和交换机通信</li>
</ul>
<p><img src="../images/Openflow-scope.png" alt="Openflow-scope.png" title=" Openflow scope"></p>
<p>专用Openflow交换机是集成Openflow协议和接口，但不支持L2和L3交换的商用交换机。专用Openflow交换机的每条流记录必须包含三个基本的行为：</p>
<ul>
<li>向特定端口转发这条流的数据包</li>
<li>封装和向控制器转发数据包</li>
<li>抛弃数据包</li>
</ul>
<p>流表中每条流记录包括：</p>
<ul>
<li>定义流的数据包头</li>
<li>定义处理的行为</li>
<li>策略，跟踪数据包</li>
</ul>
<p>而其他支持Openflow交换机（在原来L2和L3交换基础上增加Openflow特性）必须支持：在交换机原来的处理管道中转发流数据包。且交换机必须隔离生产和实验测试网络。</p>
<p><img src="../images/Openflow-switches.png" alt="Openflow switches" title="Openflow switches"></p>
<p>控制器负责在流表中添加和移除流记录，它可以是运行在PC上的简单应用。</p>
<h2 id="Openflow应用"><a href="#Openflow应用" class="headerlink" title="Openflow应用"></a>Openflow应用</h2><ol>
<li>网络管理和接入</li>
<li>VLANs</li>
<li>移动无线VOIP客户端</li>
<li>无IP网络</li>
</ol>
<h1 id="Segment-Routing"><a href="#Segment-Routing" class="headerlink" title="Segment Routing"></a>Segment Routing</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenFlow作为最主要的SDN协议，希望以一种全新转发协议颠覆现有以IP、MPLS网络架构。但是，这种激进的演进方式没有得到设备厂家及电信运营商的支持，通过对现有网络协议进行扩展和优化，推动现有网络平滑演进，实现网络开放的目标才是更加可行的选择。</p>
<p>Segment Routing就是这样的背景下，由IETF推动的支持SDN架构的新型路由转发协议。目前，Segment Routing还处于草案阶段，但是已经形成了完整的体系架构，并得到了大部分设备厂家的支持。</p>
<p>Segment Routing（SR）是一种源路由机制，用于优化IP、MPLS网络能力，可使网络具有更高的可扩展性，并以更简单的方式提供TE、FRR、MPLS VPN等功能。SR为网络提供呵呵上层应用快速交互的能力。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>和MPLS网络 类似，SR以标签交换为基础，只是对IGP协议进行简单的扩展。在SR网络中，通过Segment表示网络前缀，包括Nodal Segment(全局标签)和Adjacency Segment(本地标签)。通过将Nodal Segment和路由前缀相关联，我们可以通过最短路径到达任意节点，而转发路径是一条还是等价多路径负载分担，则取决于网络的IGP拓扑。</p>

      
    </div>
    
  </div>
  
</article>






  
    <article id="post-data-center-network-serias-1-sdn" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/22/data-center-network-serias-1-sdn/">数据中心网络系列(1)--SDN</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/22/data-center-network-serias-1-sdn/" class="article-date">
  <time datetime="2017-08-22T14:11:00.000Z" itemprop="datePublished">8月 22 2017</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-sdn/">network sdn</a></li></ul>

      
<a href="/2017/08/22/data-center-network-serias-1-sdn/#comments" class="article-comment-link" data-thread-key="cj6zpy472002o8gvgt3vm62z4" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>互联网的发展，伴随着云计算技术的革命，一开始大家关注的是依赖底层虚拟化技术将服务器资源虚拟化，提高资源利用率。而虚拟化也伴随着这波技术浪潮迅猛发展，但云计算时代下，单单虚拟化主机已经无法支撑起数据中心的发展，数据中心技术除了计算资源，还有存储和网络。因此软件定义存储（SDS）和软件定义网络（SDN）逐渐出现在大家视野，但SDN技术并不是云计算时代的产物，它的起源和发展由来已久。</p>
<h1 id="SDN的起源"><a href="#SDN的起源" class="headerlink" title="SDN的起源"></a>SDN的起源</h1><p>在数据中心网络领域，斯坦福大学的博士生 Martin Casado 敏锐地发现了问题：<em>网络设备中多平面的紧耦合导致的互相依赖，将会制约系统技术革新、稳定性、规模性，而规模问题可能带来性能问题</em>。Martin 领导了一个网络安全与管理的科研课题，实现一个灵活的、能够像计算机一样可编程的网络系统。2006 年，名为 Ethane 的网络模型作为项目成果发表，Ethane 包括了 SDN 架构中的两个重要内容：基于流表的转发和中央控制器。它不仅是 SDN 架构的雏形，也是 OpenFlow 的前身。</p>
<p>《OpenFlow : Enabling Innovation in Campus Networks》，这篇于 2008 年发表在通信网络领域顶尖会议（ACM SIGCOMM）的文章，由 Martin 的导师 Nick 教授的团队提出。OpenFlow 浮出水面，软件定义网络（SDN）被首次提出。</p>
<h1 id="SDN的概念"><a href="#SDN的概念" class="headerlink" title="SDN的概念"></a>SDN的概念</h1><p>对于SDN，大多数人（包括Gartner）是这样定义的：<strong>控制跟转发分离+开放的可编程API</strong>。但是并非控制和转发不分离就一定不是SDN，如Cisco的ACI，它是把策略管理的功能分离到了控制器上，控制协议（OSPF、BGP等）仍然运行在交换机上。广泛来说<em>开放的可编程API以及由此带来的业务敏捷性</em>就是SDN，当然纠结于定义并没多大的意义，而应该关注于SDN带来的价值，及其在网络虚拟化中的应用，为网络领域带来的革命。</p>
<p>SDN一般架构是控制和转发分离，中间是由OpenFLOW交换机组成的控制器，之上是运行在SDN的服务或应用。其中控制器和交换机的接口为南向接口，控制器和上层应用的接口为北向接口。</p>
<p>在云计算时代，离不开网络虚拟化，需要在公共网络中实现多租户的独立专用网络，这个技术叫Overlay。</p>
<h1 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h1><p>Overlay技术指的是一种网络架构上叠加的虚拟化技术，是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其它网络业务分离，并且以基于IP的基础网络技术为主。Overlay 技术是在现有的物理网络之上构建一个虚拟网络，上层应用只与虚拟网络相关。一个Overlay网络主要由三部分组成：</p>
<ul>
<li>边缘设备：是指与虚拟机直接相连的设备</li>
<li>控制平面：主要负责虚拟隧道的建立维护以及主机可达性信息的通告</li>
<li>转发平面：承载 Overlay 报文的物理网络</li>
</ul>
<p>当前主流的 Overlay 技术主要有VXLAN, GRE/NVGRE和 STT。这三种二层 Overlay 技术，大体思路均是将以太网报文承载到某种隧道层面，差异性在于选择和构造隧道的不同，而底层均是 IP 转发</p>
<h2 id="VxLAN"><a href="#VxLAN" class="headerlink" title="VxLAN"></a>VxLAN</h2><p>VxLAN(Virtual eXtensible Local Area Network) ，即扩充了的 VLAN，主要用于封装(使用UDP)、转发2层报文。其使得多个通过三层连接的网络可以表现的和直接通过一台一台物理交换机连接配置而成的网络一样处在一个 LAN 中。</p>
<p>它的实现机制是，将二层报文加上个 VxLAN header，封装在一个 UDP 包中进行传输。VxLAN header 会包括一个 24 位的 ID（称为VNI），在 VXLAN 中这类封装和解封的组件有个专有的名字叫做 VTEP。相比起 VLAN 来说，好处在于其突破了VLAN只有 4094（2^12 - 2）子网的限制，同时架设在 UDP 协议上后其扩展性提高了不少。</p>
<h3 id="VxLAN主要网络设备："><a href="#VxLAN主要网络设备：" class="headerlink" title="VxLAN主要网络设备："></a>VxLAN主要网络设备：</h3><ul>
<li>VTEP(VXLAN Tunnel End Point)：直接与终端设备比如虚机连接的设备，负责原始以太报文的VXLAN 封装和解封装，形态可以是虚拟交换机比如 Open vSwitch，也可以是物理交换机。</li>
<li>VXLAN GW(VXLAN Gateway/二层网关)：用于终结VXLAN网络，将VXLAN报文转换成对应的传统二层网络送到传统以太网络，适用于VXLAN网络内服务器与远端终端或远端服务器的二层互联。</li>
<li>VXLAN IP GW(VXLAN IP Gateway/三层网关)：用于终结 VXLAN 网络，将 VXLAN 报文转换成传统三层报文送至 IP 网络，适用于 VXLAN 网络内服务器与远端终端之间的三层互访；同时也用作不同VXLAN网络互通。</li>
</ul>
<h3 id="实现模式"><a href="#实现模式" class="headerlink" title="实现模式"></a>实现模式</h3><ul>
<li>网络Overlay ：使用物理交换机做VxLAN网络设备。<br><img src="../images/网络Overlay.jpg" alt="网络Overlay" title="网络Overlay"></li>
<li>主机Overlay：使用服务器上的软件实现VxLAN网络设备。<br><img src="../images/主机Overlay.jpg" alt="主机Overlay" title="主机Overlay"></li>
<li>混合Overlay组网<br><img src="../images/混合Overlay组网.jpg" alt="混合Overlay组网" title="混合Overlay组网"></li>
</ul>
<h1 id="NFV"><a href="#NFV" class="headerlink" title="NFV"></a>NFV</h1><p><img src="../images/NFV概念.jpg" alt="NFV概念" title="NFV概念"></p>
<p>NFV(Network Functions Virtualization)是欧洲电信联盟提出，提倡数据机房由标准的交换机、标准的服务器和标注的存储设备组成，把所有的功能移到标准的服务器上实现，强调网络功能的虚拟化。</p>
<p><img src="../images/NFV架构.jpg" alt="NFV架构" title="欧洲电信联盟给出的NFV架构"></p>
<h1 id="SDN和NFV对比"><a href="#SDN和NFV对比" class="headerlink" title="SDN和NFV对比"></a>SDN和NFV对比</h1><p>SDN处理OSI模型的2-3层，NFV处理4-7层。</p>
<p><img src="../images/SDN-NFV适用范围.jpeg" alt="SDN-NFV适用范围" title="SDN-NFV适用范围"></p>
<p><img src="../images/SDN-NFV转变.jpeg" alt="SDN-NFV转变" title="SDN-NFV转变"></p>
<p><img src="../images/SDN架构变化.jpeg" alt="SDN架构变化" title="SDN架构变化"></p>
<p><img src="../images/NFV架构变化.jpeg" alt="NFV架构变化" title="NFV架构变化"></p>
<p><img src="../images/SDN-NFV技术.jpeg" alt="SDN-NFV技术" title="SDN-NFV技术"></p>
<h1 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h1><p><img src="../images/网络虚拟化.jpg" alt="网络虚拟化" title="网络虚拟化"></p>
<p>网络虚拟化由SDN、NFV、Overlay从各个层面支撑虚拟化：</p>
<ul>
<li>SDN：定义一种控制和管理的网络架构</li>
<li>NFV：指出网络功能如何借助这个架构实现虚拟化</li>
<li>Overlay：提供一种解决数据平面转发和多租户隔离的技术手段</li>
</ul>
<h1 id="基于SDN的网络虚拟化解决方案"><a href="#基于SDN的网络虚拟化解决方案" class="headerlink" title="基于SDN的网络虚拟化解决方案"></a>基于SDN的网络虚拟化解决方案</h1><h2 id="纯软件方式"><a href="#纯软件方式" class="headerlink" title="纯软件方式"></a>纯软件方式</h2><p>以VMware的<a href="https://www.vmware.com/cn/products/nsx.html" title="NSX" target="_blank" rel="external">NSX</a>为代表，还有Juniper的Contrall、Midokura的MidoNet等公司的网络虚拟化方案。在SDN技术利用上，一种是把策略管理放在控制器上，转发表项由虚拟交换机生成；一种是控制下发转发表项。另一方面，OpenStack的网络组件Neutron则两种方式都支持。</p>
<h2 id="硬件方式"><a href="#硬件方式" class="headerlink" title="硬件方式"></a>硬件方式</h2><p>以Cisco的<a href="http://www.cisco.com/c/zh_cn/solutions/data-center-virtualization/application-centric-infrastructure/index.html?CAMPAIGN=Insieme&amp;COUNTRY_SITE=cn&amp;POSITION=sl&amp;REFERRING_SITE=Cisco.com+homepage&amp;CREATIVE=homepage+spotlight+to+ACI+launch+landing&amp;stickynav=1" title="Cisco ACI" target="_blank" rel="external">ACI</a>为代表。</p>
<h2 id="软件-硬件方式"><a href="#软件-硬件方式" class="headerlink" title="软件+硬件方式"></a>软件+硬件方式</h2><p>它是一个软件方案的思路，只是把部分对性能影响最大的操作offload到硬件SDN交换机，可以认为是一个超级网卡。</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><img src="../images/VCF.jpg" alt="VCF" title="VCF"></p>
<ul>
<li>底层：基础设备，包括终端设备、网络设备和计算存储，也包括NFV虚拟的网络单元</li>
<li>第二层：集中控制</li>
<li>上层：资源管理层</li>
</ul>
<p>强调每层向上层提供开放的可编程接口。</p>

      
    </div>
    
  </div>
  
</article>






  
    <article id="post-suibi-20160313" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/suibi-20160313/">破茧的蝴蝶--《生命之轮》读后感</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/03/13/suibi-20160313/" class="article-date">
  <time datetime="2016-03-13T14:57:47.000Z" itemprop="datePublished">3月 13 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>

      
<a href="/2016/03/13/suibi-20160313/#comments" class="article-comment-link" data-thread-key="cj6zpy43n000d8gvgxz5mh55g" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果在你停止呼吸的前刻，时间停滞了，上天眷顾的多给你总结你一生的额外时间，你会怎么抒写你的回忆录？</p>
<p>少年时期，老鼠什么都喜欢捣鼓，它天性活泼调皮，总是跑在别人面前。青年时期，熊生活安逸、喜爱冬眠。它回顾少年时代，暗自嘲笑跑来跑去的老鼠。中年时期，野牛喜欢在大草原上漫步。它悠闲自在地回味生活，期待着担起重担，成为一只雄鹰。晚年时期，鹰最喜爱在这个世界之上翱翔飞舞，它从不低头看人，因为它想鼓励人们向上看。</p>
<p>这是伊丽莎白·库伯勒·罗斯在她的书《生命之轮：生与死的回忆录》中，以鼠、熊、野牛和鹰四种动物来总结回忆自己的一生。她在这本自传中讲述自己如何成长为享誉全球的生死学大师的传奇历程，以及她对生活、死亡和濒死经验的看法。</p>
<p><img src="/images/生命之轮.jpg" alt="生命之轮" title="生命之轮"></p>
<p>伊丽莎白出生于一个瑞士普通家庭，是三胞胎中大姐，出生时只有两磅，医生和家人都生怕她无法活下去。因此，她以鼠来总结自己的少年时期并开始自己的回忆录。少年时期的伊丽莎白正好经历了世界历史上最黑暗的时代–第二次世界大战，也正是这个时期的经历让她明确自己的人生目标和使命。就像她所说的一样，万事皆有因，少年时直面过生灵涂炭，领她走近生死学的大门。她一生致力于照顾病童、艾滋病患者和关怀临终病人，于2004年去世，享年78岁。这部回忆录也是她的封笔之作。</p>
        
          <p class="article-more-link">
            <a href="/2016/03/13/suibi-20160313/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
    <article id="post-console-note" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/console-note/">console调试简介</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/03/13/console-note/" class="article-date">
  <time datetime="2016-03-12T16:00:55.000Z" itemprop="datePublished">3月 13 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

      
<a href="/2016/03/13/console-note/#comments" class="article-comment-link" data-thread-key="cj6zpy476002q8gvgtzrvohgl" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="console是什么"><a href="#console是什么" class="headerlink" title="console是什么"></a>console是什么</h1><p>现代的浏览器都自带功能非常完善且好用的web开发者工具，如firefox和chrome，或者firebug工具，提供element查看器、Console控制台、调试器、性能和网络等功能。而Console功能面板可以用于显示JS和DOM对象信息，如错误信息、调试信息、js和dom对象的信息等。并且提供了一个JS对象<code>console</code>，使用该对象api， 可以输出信息到Console面板中。打开该功能面板可以使用快捷键<code>Ctrl+Shift+k</code>（firefox）或F12（chrome、ie），下文以我常用的firefox浏览器为例介绍总结<code>console</code>。</p>
<p><img src="/images/console_1.png" alt="firefox Console 面板" title="firefox Console 面板"></p>
<h1 id="console-api"><a href="#console-api" class="headerlink" title="console api"></a>console api</h1><p>在控制台中输入<code>console</code>，会显示该对象，点击后右侧显示该对象的信息。</p>
<p><img src="/images/console_2.png" alt="firefox Console API" title="firefox Console API"></p>
<h2 id="console-log-debug"><a href="#console-log-debug" class="headerlink" title="console.log/debug"></a>console.log/debug</h2><p>这个方法是我们见到最多和使用最多的方法，简单输出信息到Console面板，支持多个参数。</p>
<p><img src="/images/console_3.png" alt="firefox Console API" title="firefox Console API"></p>
<p>log方法第一个参数支持字符串替换模式：</p>
<ul>
<li>%s 代替字符串</li>
<li>%d 代替整数</li>
<li>%f 代替浮点数</li>
<li>%o 代替Object</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;%s,this is integer:%d,this is Object:%o&#39;,&#39;Hello&#39;,100,&#123;name:&#39;ice&#39;&#125;)&#10;// Hello,this is integer:100,this is Object: Object &#123; name: &#34;ice&#34; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="console-info，warn，error-exception"><a href="#console-info，warn，error-exception" class="headerlink" title="console.info，warn，error/exception"></a>console.info，warn，error/exception</h2><p>这4种方法与<code>console.log</code>方法一样，只是显示的图标和文字颜色不一样。</p>
        
          <p class="article-more-link">
            <a href="/2016/03/13/console-note/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
    <article id="post-webpack-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/29/webpack-note-1/">webpack入门</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/29/webpack-note-1/" class="article-date">
  <time datetime="2016-02-29T13:30:39.000Z" itemprop="datePublished">2月 29 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

      
<a href="/2016/02/29/webpack-note-1/#comments" class="article-comment-link" data-thread-key="cj6zpy43i000a8gvg1ewp5nri" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>webpack是一个模块加载器和打包工具。不只是js文件，webpack把所有资源当作模块（js、图片、样式表、模板等）来处理和使用。</p>
<p>优势：</p>
<ul>
<li>将依赖树分隔成块按需加载</li>
<li>减少初始化加载时间</li>
<li>所有静态资源都可以模块化</li>
<li>扩展性强，插件机制完善</li>
<li>webpack以commonJS形式书写脚本，也支持AMD/CMD，因此便于代码迁移</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2016/02/29/webpack-note-1/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
    <article id="post-react-note-2" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/29/react-note-2/">React实践（一）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/29/react-note-2/" class="article-date">
  <time datetime="2016-02-29T12:57:23.000Z" itemprop="datePublished">2月 29 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

      
<a href="/2016/02/29/react-note-2/#comments" class="article-comment-link" data-thread-key="cj6zpy457001f8gvg838gv4bp" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React组件实践"><a href="#React组件实践" class="headerlink" title="React组件实践"></a>React组件实践</h1><p>最近在学习React，上一篇写了自己React入门的一些笔记。组件<em>component</em>作为React的主要特性，于是作为自己的实践开发了评论组件，一般上是需要与后台交互，但为了简便就省了这一步，而直接在页面造了假数据进行测试。</p>
<h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><p>|– CommentBox<br>    |– CommentList<br>        |– Comment<br>        |– Pagination<br>    |– CommentForm</p>
<h2 id="Comment子组件"><a href="#Comment子组件" class="headerlink" title="Comment子组件"></a>Comment子组件</h2><p>该组件相对简单，作为每条评论的UI显示，包括用户名和评论。所以只需使用<code>render（）</code>方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Comment = React.createClass(&#123;&#10;  render: function() &#123;&#10;    return (&#10;      &#60;div className=&#34;list-group-item&#34;&#62;&#10;        &#60;div className=&#34;row-action-primary&#34;&#62;&#10;            &#60;i className=&#34;mdi-file-folder&#34;&#62;&#60;/i&#62;&#10;        &#60;/div&#62;&#10;        &#60;div className=&#34;row-content&#34;&#62;&#10;          &#60;h4 className=&#34;list-group-item-heading&#34;&#62;&#123;this.props.username&#125;&#60;/h4&#62;&#10;          &#60;p className=&#34;list-group-item-text&#34;&#62;&#123;this.props.comment&#125;&#60;/p&#62;&#10;        &#60;/div&#62;&#10;      &#60;/div&#62;&#10;    );&#10;  &#125;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>用户名和评论分别使用组件的参数<code>this.props.username</code>和<code>this.props.comment</code>传递。</p>
        
          <p class="article-more-link">
            <a href="/2016/02/29/react-note-2/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
    <article id="post-react-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/27/react-note-1/">React入门</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/27/react-note-1/" class="article-date">
  <time datetime="2016-02-27T11:37:23.000Z" itemprop="datePublished">2月 27 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

      
<a href="/2016/02/27/react-note-1/#comments" class="article-comment-link" data-thread-key="cj6zpy45a001i8gvgeej0rclf" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="why-React"><a href="#why-React" class="headerlink" title="why React"></a>why React</h1><p>React是Facebook开发的用来创建用户界面的<em>JavaScript库</em>，相当于MVC中的<em>V</em>（视图）。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>构建随着时间数据不断变化的大规模应用程序。</p>
<ul>
<li>简单。表达某一个时间点应用程序是个什么样子的，当底层数据改变后，React会决定是否更新用户界面且自动处理。</li>
<li>声明式。数据变化后自会更新变化的部分。</li>
</ul>
<h1 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h1><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>在web应用中，更新操作DOM通常比较昂贵且耗时，每次更新都可能导致重绘或重排。React通过抽象出一个js对象来模拟DOM，即<em>Virtual DOM</em>，来描述虚拟DOM是什么样子的（React使用<code>render()</code>来描述虚拟的DOM节点），并决定是否更新重绘真实的DOM。等到事件循环结束后，React会利用diff算法比较新旧Virtual DOM，计算出最快的方式更新真实DOM。</p>
<h2 id="component"><a href="#component" class="headerlink" title="component"></a>component</h2><p>Virtual DOM的节点就是抽象、封装好的组件，通过React你<em>唯一</em>要做的事情就是构建组件。借助组件使React具有可组合性，关注界面分离。当组件的<em>state</em>或<em>props</em>改变，React会比较新旧虚拟DOM，决定是否更新界面。</p>
<p>可以认为组件是简单的函数，接受 <code>props</code> 和 <code>state</code>作为参数，然后渲染出HTML。组件只能渲染单个根节点，如果想要返回多个节点，它们<em>必须</em>被包含在同一个节点里。</p>
<p>组件其实是状态机（State Machine）。根据界面不同状态然后渲染这些状态，让用户界面和数据保持一致。<br>React里，只需更新组件的 state（使用唯一的<code>this.setState(data, callback)</code>方法），然后根据新的state 重新渲染用户界面，React 来决定如何最高效地更新 DOM。因此勿在组件里直接操作DOM。</p>
        
          <p class="article-more-link">
            <a href="/2016/02/27/react-note-1/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
    <article id="post-suibi-20160220" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/20/suibi-20160220/">工作or生活</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/20/suibi-20160220/" class="article-date">
  <time datetime="2016-02-20T05:42:50.000Z" itemprop="datePublished">2月 20 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>

      
<a href="/2016/02/20/suibi-20160220/#comments" class="article-comment-link" data-thread-key="cj6zpy43t000i8gvgzycs23a7" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>春节后第一个工作周已经结束了，虽说能很快重新进入工作状态，但有些感觉毅然笼罩我的上空。我知道这不是节后综合征，放假前的几天毅然坚守在空荡荡的办公室里，节后第一天也没有不想起床上班的惰性。按理说我应该是个热爱工作的人，但我终究是明白的，这份工作已经成为我生活的阴霾。</p>
<p>一份工作可以给你带来什么，金钱、乐趣还是成就感？从小就被教导要找份自己感兴趣的工作，然后为之燃烧，但又有多少人能真正从事自己所喜欢的事业。或许很多人都不知道自己喜欢什么工作，可讨厌一份工作对每个人来说都是明确的。我们对讨厌的情感非常敏感，讨厌的人，讨厌的风景，讨厌的事，我们心里十分清楚这种讨厌，甚至会对这种讨厌表现出决绝的意志。可面对喜欢的情感时，我们常常无法确信，我们会犹豫，会患得患失。</p>
<p>有人说工作是为了生存，这从动物的求生意识来说是没错的，每个社会人都离不开衣食住行，为了生存我们只能去劳动、去工作。为了生存，我们可以从事体力劳动来换取面包，为了生存，我们可以忍受工作对精神的摧残，为了生存，我们可以做着讨厌的工作。按照马斯洛的需求层次理论，为了生存去工作只是最底层的生理需要，那么没有生存也就没法去追求更高层次的需要了。但若只为了生存什么样的工作不能去做，你做着讨厌、压抑的工作，一边抱怨一边坚持，你会说，“没办法，我是为了生存。”可生存的方式多种多样，何必拘泥于一份工作，何必在你讨厌的工作下摧残自己的身心。若只是为了生存，什么样的工作不能去做，你若有体力开玩笑的说还可以去搬砖。当然我知道你不会离开这份讨厌的工作去搬砖，而你的生存说并不能掩盖你已被工作所奴役的既成事实。</p>
<p>工作并不止是为了生存，在工作中也能实现更高的需要，如成就感、尊重等。所以很多人不一定从事喜欢的工作，但他们仍能保持热情与冲劲，他们热爱的不是特定的工作，而是工作本身。他们不再只追求于生存，他们更希望从工作中得到安全感、满足和幸福感。</p>
<p>可当工作成为一座大山压在你的生活上时，你会怎么办？有些人因为工作没了生活，他们的信仰是“为了生活才要这么努力去工作”，这是否会让你想起钓鱼者和商人的故事，兜兜转转，我们想要的生活可能就在此刻。我们该为了工作去生活，还是为了生活去工作？此时此刻我也没有想清楚，但若工作影响到生活，若工作影响到了自己的心态、心情，或许就该离开。细想自己现在的状态，找不到留下来的任何理由，却知道它幽暗的黑影一直笼罩着我，不断侵蚀我的内心。</p>
<p>曾经看过这么一个故事，一对年轻的夫妻逃离了大城市，在偏远的山上安家。夫妻俩都是手艺人，一个负责制作陶瓷，一个负责给陶瓷上色，经济来源自己的手艺，自己所热爱的事。他们远离了烦嚣的城市，过着恬然自得的田园生活，他们知道自己所要的生活是怎样的，同时他们又把工作融于生活，或者是在生活中工作。我想这是最好的状态吧，无所谓是为工作而生活还是为生活而工作。</p>
<p>什么是最好的生活？如果你是富二代，可以不用为了生计而拼命工作，可以做自己想做的事，过自己想要的生活。那么这种状态就是最好的生活吗？我们对工作的定义是否过于狭隘，工作不只是去某公司上班或者创业，还可以是做自己所热爱的事情。一个人热爱写作，把写作当成自己的工作，即使这个工作无法带来收入，这难道不也是工作吗？一个人喜欢玩模型，当他聚精会神制作模型时，我们也可称他正在工作。若一个人没有工作，也没有自己的兴趣爱好，那么生活就只剩活着。</p>
<p>不管如何去定义工作，我都想从中得到充实感和满足感，当然我不能免俗的不要求收入。我确信的是工作只是生活的子集，工作没有如此大的力量可以反客为主，但它又影响着生活。</p>
<blockquote>
<p>  癞蛤蟆<br>  菲利普·拉金<br>  为什么要让工作这只癞蛤蟆<br>  蜷伏在我的生活上？<br>  难道不能用智慧作长叉<br>  撵走这个丑东西？<br>  一星期六天都被它污玷，<br>  用它令人作呕的毒液–<br>  只为了付清几张小账单！<br>  那可太不划算。<br>  许多家伙靠小聪明过活：<br>  讲师，笨舌头，<br>  无赖，废人，莽汉–<br>  不见得变成穷光蛋；<br>  许多家伙生活在陋巷，<br>  铁桶里面烧着火，<br>  嚼着罐装沙丁鱼和风吹落的野果–<br>  好像也蛮快活。<br>  他们的小子光着脚，<br>  老婆糟得没法说，<br>  皮包骨瘦得像赛狗–但也<br>  没有谁真的挨饿。<br>  啊，但愿我有足够的勇气<br>  大喊一声“去你妈的养老金！”<br>  但我清楚，再清楚不过，那正是<br>  美梦存在的根底：<br>  因为有些什么也盘踞在我心里，<br>  如同一只癞蛤蟆；<br>  它蹲伏的屁股沉得好像坏运气，<br>  冷得有如雪地，<br>  它从不允许我<br>  用哄骗的手段<br>  一口气猎取<br>  名望、金钱和美女。<br>  我不是说，这一个体现<br>  另一个的精神真理；<br>  我是想说，一旦你同时拥有，<br>  就很难将任何一个舍弃。</p>
</blockquote>

      
    </div>
    
  </div>
  
</article>






  
    <article id="post-suibi-20160218" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/18/suibi-20160218/">乌合之众</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/18/suibi-20160218/" class="article-date">
  <time datetime="2016-02-18T15:33:37.000Z" itemprop="datePublished">2月 18 2016</time>
</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

      
<a href="/2016/02/18/suibi-20160218/#comments" class="article-comment-link" data-thread-key="cj6zpy441000m8gvgury4pzbz" data-short-name="iceccb" style="display:none">comments</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>书名：乌合之众 大众心理研究<br>作者： 古斯塔夫·勒庞</p>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><blockquote>
<p>考虑事物虚幻的形状，远比考虑它们的真正形状更重要，因为只有它们，是我们能看到并加以再现的形状。有时不真实的东西比真实的东西包含着更多的真理。</p>
<p>群体感情的狂暴，会因责任感的彻底消失而强化。意识到肯定不会受到惩罚，而且人数越多，这一点越是肯定。以及因为人多势众而一时产生的力量感，会使群体表现出一些孤立的个人不可能有的情绪和行动，所以群体很容易干出最恶劣的极端勾当。</p>
<p>教育既不会使人变得更道德，也不会使他更幸福。它既不能改变他的本能，也不能改变他天生的热情，而且有时（只要进行不良引导即可）害处远大于好处。</p>
<p>推动各民族演化的主要因素，永远不是真理，而是谬误。</p>
</blockquote>
<h1 id="群体心理"><a href="#群体心理" class="headerlink" title="群体心理"></a>群体心理</h1><h2 id="群体的一般特征"><a href="#群体的一般特征" class="headerlink" title="群体的一般特征"></a>群体的一般特征</h2><p>群体的含义</p>
<ul>
<li>聚集在一起的个人，无论民族、职业、性别和以何目的而聚集。</li>
<li>聚集成群的人，感情和思想采取同一方向，自觉个性的消失。</li>
</ul>
<h3 id="群体的特点"><a href="#群体的特点" class="headerlink" title="群体的特点"></a>群体的特点</h3><p>构成群体个人，无论是什么身份、性格、智力的人，他们获得一种集体心里，使他们的感情、思想和行为变得与个人时不同。就像形成一个新的生命体，且与形成的个体的特点有很大的不同。</p>
<p>无意识构成种族的先天禀性，在集体心理中，个人的才智被削弱，从而个性也被削弱，异质性被同质性所吞没，无意意识的品质占上风。群体中的个人成为意志支配的玩偶，可能由一个有教养的人变成残暴、狂热的野蛮人。</p>
<ul>
<li>约束个人的责任感消失。个人在群体中敢于发泄本能的欲望，因为群体数量上约束的力量大大降低。</li>
<li>传染。感情和行动具有传染性，足以使个人愿意为集体利益牺牲个人理疗仪。</li>
<li>易于接受暗示。</li>
</ul>
<p>群体的智力总低于孤立的个人，易于犯罪又可能成为英雄。</p>
        
          <p class="article-more-link">
            <a href="/2016/02/18/suibi-20160218/#more">继续阅读</a>
          </p>
        
      
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-category">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-recent">最近</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/31/data-center-network-serias-3-ONOS/">数据中心网络系列(3)--ONOS</a>
          </li>
        
          <li>
            <a href="/2017/08/25/data-center-network-serias-2-openflow/">数据中心网络系列(2)--openflow</a>
          </li>
        
          <li>
            <a href="/2017/08/22/data-center-network-serias-1-sdn/">数据中心网络系列(1)--SDN</a>
          </li>
        
          <li>
            <a href="/2016/03/13/suibi-20160313/">破茧的蝴蝶--《生命之轮》读后感</a>
          </li>
        
          <li>
            <a href="/2016/03/13/console-note/">console调试简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title widget-title-tag">标签</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/ejs/" style="font-size: 16px;">ejs</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/language/" style="font-size: 10px;">language</a> <a href="/tags/network-openflow/" style="font-size: 10px;">network openflow</a> <a href="/tags/network-sdn/" style="font-size: 12px;">network sdn</a> <a href="/tags/nodejs/" style="font-size: 12px;">nodejs</a> <a href="/tags/web/" style="font-size: 20px;">web</a> <a href="/tags/电影/" style="font-size: 14px;">电影</a> <a href="/tags/话剧/" style="font-size: 10px;">话剧</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/读后感/" style="font-size: 14px;">读后感</a> <a href="/tags/随笔/" style="font-size: 18px;">随笔</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ice Chan<br>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">博文</a>
  
</nav>
    
<script src="/js/jquery-1.9.1.min.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>